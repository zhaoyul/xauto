# -*- coding: utf-8 -*-
from django.conf import settings
from django import forms
from django.forms import ModelForm
from django.contrib.auth.forms import UserCreationForm, UserChangeForm
from django.utils.translation import ugettext_lazy as _
from django.db.models.base import ObjectDoesNotExist
from django.contrib.auth.models import User
from django.core.urlresolvers import reverse
from registration.forms import RegistrationFormTermsOfService
from crispy_forms.helper import FormHelper
from crispy_forms.layout import Submit
from crispy_forms.layout import Layout, HTML, Fieldset, ButtonHolder, Div
from django.contrib import messages
from django.contrib.auth.forms import PasswordChangeForm #SetPasswordForm
#from accounts.models import UserProfile
#from mieszkanie.layout import BootstrappedSubmit
from django.contrib.auth.forms import AuthenticationForm

rev = lambda s: reverse(s)

# force emails to be uniqe
User._meta.get_field_by_name('email')[0]._unique = True

class EmailAuthenticationForm(AuthenticationForm):
    username = forms.CharField(label=_("Username"))

dummy_trans = _("If you don't want to change your password leave these fields empty.")

attrs_dict = {'class': 'required'}
class RegistrationForm(RegistrationFormTermsOfService):
    first_name = forms.CharField(label=_("First name"), max_length=30)
    last_name = forms.CharField(label=_("Last name"), max_length=30)
    tos = forms.BooleanField(widget=forms.CheckboxInput(attrs=attrs_dict),
            label=_(u'I have read and agree to the <a href="%(url)s">Terms of Service</a>') % {'url': settings.TOS_URL},
                             error_messages={'required': _("You must agree to the terms to register")})

    def __init__(self, *args, **kwargs):
        super(RegistrationForm, self).__init__(*args, **kwargs)
        self.helper = FormHelper()
        self.helper.form_id = 'id-RegistrationForm'
        self.helper.form_method = 'post'
        self.helper.form_action = 'registration_register'
        self.helper.form_style = 'inline'
        self.helper.form_tag = False
        self.helper.layout = Layout(
                Fieldset(_('Register to be able to change your photo'),
                    'first_name',
                    'last_name',
                    'email',
                    'password1',
                    'password2',
                    'tos',
                    ),
        )
        self.fields.keyOrder = ('first_name', 'last_name', 'email', 'password1', 'password2', 'tos') # username is autogenerated so we remove it


    def clean_email(self):
        email = self.cleaned_data["email"]
        try:
            user = User.objects.get(email=email)
            raise forms.ValidationError(_("This email address already exists."))
        except User.DoesNotExist:
            return email

class ProfileForm(ModelForm):
    email = forms.EmailField(label=_(u"E-mail"), help_text='')

    def __init__(self, *args, **kwargs):
        super(ProfileForm, self).__init__(*args, **kwargs)
        uni_fields = ['email']

        if self.instance.pk:  # profile and user already exists
            self.fields['email'].initial = self.instance.user.email
        #else:  # just create profile, don't overwrite email assigned to User
        #    del self.fields['email']
        #    uni_fields.remove('email')
        
        self.helper = FormHelper()
        self.helper.form_id = 'id-ProfileForm'
        self.helper.form_style = 'inline'
        self.helper.form_tag = False
        self.helper.layout = Layout(
                Fieldset(_('Profile'),
                    *uni_fields
                    ),
                ButtonHolder(BootstrappedSubmit('submit', _('Submit')))
        )
 
    #class Meta:
    #    model = UserProfile
    #    exclude = ('user',)        
 
    def save(self, *args, **kwargs):
        """
        Update the primary email address on the related User object as well.
        """
        profile = super(ProfileForm, self).save(*args,**kwargs)
        if self.instance.pk:  # profile exists
            u = self.instance.user
            u.email = self.cleaned_data['email']
            u.save()
        return profile


#class AccountForm(SetPasswordForm):
class AccountForm(forms.ModelForm):
    old_password = forms.CharField(label=_("Old password"),
                                   widget=forms.PasswordInput, required=False)
    new_password1 = forms.CharField(label=_("Password"), 
                                    widget=forms.PasswordInput, required=False)
    new_password2 = forms.CharField(label=_("Password confirmation"),
                                    widget=forms.PasswordInput, required=False)

    def __init__(self, *args, **kwargs):
        super(AccountForm, self).__init__(*args, **kwargs)
      
        self.fields['first_name'].required = True
        self.fields['last_name'].required = True

        self.helper = FormHelper()
        self.helper.form_id = 'id-AccountForm'
        self.helper.form_style = 'inline'
        self.helper.form_tag = False
        self.helper.layout = Layout(
                Fieldset(_(u'Your data'),
                    'first_name',
                    'last_name',),
                Fieldset(_(u'Password'),
                    HTML("""{% load i18n %}
                    <p class="info">{% trans "If you don't want to change your password leave these fields empty." %}</p>
                    """),
                    'old_password',
                    'new_password1',
                    'new_password2',),
        )

    class Meta:
        model = User
        fields = ('first_name', 'last_name', 'old_password', 'new_password1',
                  'new_password2')

    def clean_new_password2(self):
        password1 = self.cleaned_data.get('new_password1')
        password2 = self.cleaned_data.get('new_password2')
        if password1 != password2:
            raise forms.ValidationError(\
                    _("The two password fields didn't match."))
        return password2

    def clean(self):
        if self.instance.pk and self.fields.has_key('old_password'):
            password1 = self.cleaned_data.get('new_password1')
            password2 = self.cleaned_data.get('new_password2')
            if password1 and password2 and password1 == password2:
                if not self.instance.check_password(\
                    self.cleaned_data.get('old_password', '')):
                    self._errors['old_password'] = self.error_class([_("Your old password was entered incorrectly. Please enter it again.")])
                    del self.cleaned_data['old_password']
        return self.cleaned_data

    def save(self, commit=True):
        form = super(AccountForm, self)
        user = form.save()
        password = self.cleaned_data["new_password1"]
        if password:
            user.set_password(password)
            user.save()
        return user


